import objective_functions as obj
import optimizer as opt

x = [[-2.0, -2.0],
     [-1.0, -2.0],
     [0.0, -2.0],
     [1.0, -2.0],
     [2.0, -2.0],
     [-2.0, -2.0],
     [-1.0, -1.0],
     [0.0, -1.0],
     [1.0, -1.0],
     [2.0, -1.0],
     [-2.0, 0.0],
     [-1.0, 0.0],
     [0.0, 0.0],
     [1.0, 0.0],
     [2.0, 0.0],
     [-2.0, 1.0],
     [-1.0, 1.0],
     [0.0, 1.0],
     [1.0, 1.0],
     [2.0, 1.0],
     [-2.0, 2.0],
     [-1.0, 2.0],
     [0.0, 2.0],
     [1.0, 2.0],
     [2.0, 2.0]]
# fx was generated by passing x to the 'quadratic' function' and rounding the results.
fx = [0.16, 0.34, 1.04, 2.26, 4, 0.16, 0.04, 0.26, 1, 2.26, 1.04, 0.26, 0, 0.26, 1.04, 2.26, 1, 0.26, 0.04,
            0.34, 4.3, 2.26, 1.04, 0.34, 0.16]

func = obj.quadratic
theta = [0.261, 0.261, 0.0, 0.0, -0.481, 0.0]
weight = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
          0.5, 0.5, 0.5, 0.5]
bootstrap = None # opt._bootstrap_sample(len(x), len(x))

precision = 3
theta_min = [0.26886495, 0.26838753, -0.01241092, 0.01181188, -0.49181186, -0.02209403]

minimum = opt.nelder_mead(theta, opt.least_squares_objective_function,
                          args=(func, x, fx, weight, bootstrap))

print(minimum)

# class WeightsTest():
#     func = obj.sphere
#     bounds = [(-1.5, 1.5), (-0.5, 2.5)]
#     constraints = [{'type': '<=0', 'func': const.f3}]
#     initial_pt_valid = [-0.5, 1.0]
#     initial_pt_invalid = [-500.0, 1000.0]
#     global_minimum = [0.0, 0.0]

